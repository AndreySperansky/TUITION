Специальные символы:  \.^$+*{}[]()|

.	Один любой символ, кроме новой строки \n.
?	0 или 1 вхождение шаблона слева
+	1 и более вхождений шаблона слева
*	0 и более вхождений шаблона слева
\w	Любая цифра или буква (\W — все, кроме буквы или цифры)
\d	Любая цифра [0-9] (\D — все, кроме цифры)
\s	Любой пробельный символ (\S — любой непробельный символ)
\b	Граница слова
[..]	Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках)
\	Экранирование специальных символов (\. означает точку или \+ — знак «плюс»)
^ и $	Начало и конец строки соответственно
{n,m}	От n до m вхождений ({,m} — от 0 до m)
a|b	Соответствует a или b
()	Группирует выражение и возвращает найденный текст
\t, \n, \r	Символ табуляции, новой строки и возврата каретки соответственно


● ? — символ входит ноль или один раз,
● * — любое количество вхождений, включая ноль,
● + — одно или более вхождений символа в строку.
● ^ - Начало текста (начало строки с флагом re.M)
● $ - Конец текста (конец строки с флагом re.M - позиция перед символом \n)
● \A - Начало текста
● \Z - Конец текста
● \b - Граница слова (внутри символьных классов [] соответствует символу BACKSPACE)
● \B - Граница не слова (зависим от флага re.ASCII)
● . - соответствует любому одиночному символу (не включает символ переноса строки)
● [abcdef] - соответствует любому одиночному символу из скобок
● [a-c] - соответствует любому одиночному символу из диапазона символов (c[ab]t  match cat)
● | - отделяет два шаблона строки, и значение должно соответствовать одну из этих шаблонов
● # - соотвествует любому одиночному цифровому символу (2#5 finds 205,215,...,295)
● ! - соответствует люому символу символу не в скобках (h[!oa]t finds hit  and not hot)
● % - соотвествует нулю или любому количеству символов (bl% - black blue blob)
● // - экранирует специальный символ
● \d соответствует любой цифре, если используется кодировка Юникода. В случае установки флага re.ASCII, то диапазону цифр [0-9]
● \D соответствует любому нецифровому символу для Юникода. В случае установки флага re.ASCII - диапазону символов [^0-9]
● \s Для юникода - любой пробельный символ. Для re.ASCII - символьному классу [\t\n\r\f\v]
● \S Для юникода - любой  не пробельный символ. Для re.ASCII - символьному классу [^ \t\n\r\f\v]
● \w Для Юникода - любой символ слова. При Флаге re.ASCII - набору символов [a-zA-Z0-9]
● \W Для Юникода - любой не символ слова. При Флаге re.ASCII - набору символов [^a-zA-Z0-9]

  *** ПРОВЕРКИ

(?=expr)    Проверка на совпадение с выражением expr продолжения строки без включения expr. Опережающая проверка
(?!expr)    Проверка на НЕсовпадение с выражением expr продолжения строки без включения expr. Опережающая проверка
(?<=expr)   Проверка на совпадение с выражением expr продолжения строки с включением expr. Ретроспективная проверка
(?<!expr)   Проверка на НЕсовпадение с выражением expr продолжения строки с включением expr. Ретроспективная проверка


  ***  ФЛАГИ

re.A, re.ASCII  - \b \B \s \S \w \W  действуют так, как если бы они применялись к тексту, содержащему только ASCII
re.U, re.UNICODE    - по умолчанию и лучше оставаться в нем
re.I, re.IGNORECASE - Проверка без участия регистра символов
re.M, re.MULTILINE - влияет на действие ^  и   $
re.S, re.DOTALL - при данном флаге .  включает в себя и символ \n
re.X, re.VERBOSE - позволяет включать в решулярные выражения пробелы и комментарии
re.DEBUG    - включает режим отладки при компеляции регулярного выражения


  *** Квантификаторы ***

Квантификаторы {m,n},+,*,?
m - минимальное число совпадений с выражением
n - максимальное число совпадений с выражением

{m} - повторение выражения ровно m раз (эквывалент{m,m})
{m,} - повторение от m и более раз
{,n} - повторения не более n раз
{m,}? - минорный режим
{,n}? - минорный режим

* = {0,}  - от ноля и более
+ = {1,}  - от одного и более
? = {0,1} - от 0 до 1   (не путать с символом минорного режима)

()   сохраняющие группирующие скобки
(?: ) несохраняющие группирующие скобки

Общий синтаксис к сохранению регулярного выражения
\i (i - натуральное число: 1, 2, 3)
	(?P<name>) - присвоение имени
	(?P<name>) - использование имени

  ** ПРОВЕРКА ГРУППИРУЮЩЕГО ВЫРАЖЕНИЯ
  (?P<name>[\''']) например, имеем группирующее выражение

  тогда

  (?(id|name)yes_pattern) - если группа найдена то выполнить шаблон yes_pattern

	или

  (?(id|name)yes_pattern|no_pattern) - если группа найдена то выполнить шаблон yes_pattern
                                        или выполнить шаблон no_pattern если группа не была найдена


  ** ФЛАГИ **
  (?flags),   где flags - один или несколько флагов

  a - re.ASCII
  i - re.IGNORECASE
  m - re.MULTILINE
  s - re.DOTALL
  x - re.VERBOSE

 МЕТОДЫ re.search, re.finditer, re.findall, re.match, re.split

 re.search(pattern, string, flags)
 re.finditer(pattern, string, flags)
 re.findall(pattern, string, flags)
 re.match(pattern, string, flags)
 re.split(pattern, string, flags)

 pattern - регулярное выражение
 string - анализируемая строка
 flags - один или несколько флагов

 re.sub(pattern, erpl, string, count, flags)
repl - строка или функция для замены найденного выражения
count - максимальное чичло замен
pattern - регулярное выражение
string - анализируемая строка
flags - один или несколько флагов

re.compile(pattern, flags)

выполняет компиляцию регулярного выражения и возвращает его в виде
экземпляра класса Pattern




